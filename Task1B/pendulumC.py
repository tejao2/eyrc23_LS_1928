# Once the CoppeliaSim ChildScripts are working, copy the child script for "Pendulum C" and paste it here.

 #python

###### GLOBAL VARIABLES HERE ######
base = None
motor = None
arm = None
pendulum = None
U = None
pend_ini= None
diff = 0
# You can add variables here 
# as required by your implementation.
###################################

def sysCall_init():
   
    global base, motor, arm, pend, U, pend_ini, arm_ini, x5, x6, x1, x2, x3, x4
    
    # To Get references to the objects in the scene
    base = sim.getObjectHandle("Base_C")
    motor = sim.getObjectHandle("Motor_C")
    arm = sim.getObjectHandle("Arm_C")
    pend = sim.getObjectHandle("Pendulum_C")
    x1 = 0 
    x2 = 0 
    x3 = 0 
    x4 = 0 
    x5 = 0 
    x6 = 0 

    
    #################################
    
    pend_orientation = sim.getObjectOrientation(pend, base)  
    angle_xp, angle_yp, angle_zp = pend_orientation
    yaw, pitch, roll = sim.alphaBetaGammaToYawPitchRoll(angle_xp, angle_yp, angle_zp) 
    # converting to yaw-pitch-roll 
    pend_ini = roll
    
    arm_orientation = sim.getObjectOrientation(arm, base) 
    angle_xa, angle_ya, angle_za = arm_orientation
    yaw_a, pitch_a, roll_a = sim.alphaBetaGammaToYawPitchRoll(angle_xa, angle_ya, angle_za)
    # converting to yaw-pitch-roll
    arm_ini = yaw_a 
    pass

def sysCall_actuation():
    # put your actuation code here
    # This function will be executed at each simulation time step

    ####### ADD YOUR CODE HERE ######
    # Hint: Use the error feedback and apply control algorithm here
    #       Provide the resulting actuation as input to the actuator joint
    
    # Example psuedo code:
    #   x1 = error_state_1; # Error in states w.r.t desired setpoint
    #   x2 = error_state_2;
    #   x3 = error_state_3;
    #   x4 = error_state_4;
    #   k = [gain_1 , gain_1, gain_3, gain_4];      # These gains will be generated by control algorithm. For ex: LQR, PID, etc.
    # U = -k[1]*x1 +k[2]*x2 -k[3]*x3 +k[4]*x4; # +/- Sign convention may differ according to implementation
    
    global x1, x2, x3, x4, x5, x6
    #K = [ 0.4116,   0.7071,  -0.3941,  -4.7559]
    #U = K[0]*x1 - K[1]*x2 + K[2]*x3 + K[3]*x4
    #U = 250 * x4 #  - 0.5 * x2 + 0.2 * x3 #*- 0.03 * x1#- 0.5 * x3
    #U = 30 * x4 #+ 0.07 * x3
    U = 120 * x4 - 0.05 * x3- 0.45 * x2 - 0.08*x1 #+ 0.008 * x5
    
    sim.setJointTargetVelocity(motor, -U)
    #print(str(pend_pos) + " " + str(arm_pos) + " " + str(x4) + " " + str(U))
    
  
    #print(str(x2) + " " + str(pend_pos) + " " + str(x4) + " " )
    
    #   Set_joint_actuation(U);                     # Provide this calculated input to system's actuator
    #################################
    
    pass

def sysCall_sensing():
    # put your sensing code here
    # This function will be executed at each simulation time step
    
    ####### ADD YOUR CODE HERE ######
    # Hint: Take feedback here & do the error calculation
    global pend_ini, arm_ini, x5, x6, x1, x2, x3, x4
    pend_orientation = sim.getObjectOrientation(pend, base)
    angle_xp, angle_yp, angle_zp = pend_orientation
    yaw, pitch, roll = sim.alphaBetaGammaToYawPitchRoll(angle_xp, angle_yp, angle_zp) 
    pend_pos = roll 
    
    arm_orientation = sim.getObjectOrientation(arm, base)  
    angle_xa, angle_ya, angle_za = arm_orientation
    yaw_a, pitch_a, roll_a = sim.alphaBetaGammaToYawPitchRoll(angle_xa, angle_ya, angle_za)
    arm_pos = yaw_a 
    
    
    x2 = arm_ini-arm_pos
    x1 = 0-(x2/0.010)
    x4 = pend_ini-pend_pos
    x3 = 0-(x4/0.010)
    x5 = x5 + x2
    x6 = x6 + x1
    pass

def sysCall_cleanup():
    # do some clean-up here
    # This function will be executed when the simulation ends
    
    ####### ADD YOUR CODE HERE ######
    # Any cleanup (if required) to take the scene back to it's original state after simulation
    # It helps in case simulation fails in an unwanted state.
    #################################
    pass

# See the user manual or the available code snippets for additional callback functions and details
